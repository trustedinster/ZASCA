# ZASCA 安全配置指南

## 1. 安全架构概述

ZASCA 采用多层次安全防护体系，从业务应用到基础设施提供全方位安全保障。

### 1.1 安全设计原则
- **纵深防御**：多层安全控制机制
- **最小权限**：基于角色的最小权限分配
- **零信任**：不信任任何网络流量
- **安全审计**：完整的操作日志记录

### 1.2 安全控制层次
```
应用层 ── 认证授权、输入验证、会话管理
传输层 ── TLS/SSL 加密、证书管理
数据层 ── 数据加密、访问控制、备份安全
系统层 ── 操作系统加固、防火墙配置
物理层 ── 机房安全、设备保护
```

## 2. 身份认证安全

### 2.1 用户认证机制

#### 密码策略
```python
# settings.py 中的密码策略配置
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# 密码复杂度要求
PASSWORD_MIN_LENGTH = 12
PASSWORD_REQUIRE_UPPERCASE = True
PASSWORD_REQUIRE_LOWERCASE = True
PASSWORD_REQUIRE_DIGITS = True
PASSWORD_REQUIRE_SPECIAL_CHARS = True
```

#### 多因素认证 (MFA)
```python
# 可选的 TOTP 配置
MFA_ENABLED = True
MFA_REQUIRED_FOR_ADMIN = True
MFA_BACKUP_CODES_COUNT = 10

# TOTP 设置
TOTP_ISSUER = "ZASCA"
TOTP_DIGITS = 6
TOTP_INTERVAL = 30
```

### 2.2 会话安全管理

#### 会话配置
```python
# settings.py
SESSION_COOKIE_AGE = 3600  # 1小时
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_COOKIE_SECURE = True  # 仅 HTTPS
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'

# 会话引擎
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'
```

#### 登录限制
```python
# 登录尝试限制
MAX_LOGIN_ATTEMPTS = 5
LOGIN_LOCKOUT_TIME = 300  # 5分钟

# IP 限制
ALLOWED_LOGIN_IPS = ['192.168.1.0/24']  # 可选
BLOCK_SUSPICIOUS_IPS = True
```

## 3. 授权与访问控制

### 3.1 RBAC 权限模型

#### 角色定义
```python
# 权限角色配置
ROLES = {
    'super_admin': {
        'name': '超级管理员',
        'permissions': ['*'],  # 所有权限
        'description': '系统最高权限用户'
    },
    'host_admin': {
        'name': '主机管理员',
        'permissions': [
            'hosts.view_host',
            'hosts.change_host',
            'hosts.delete_host',
            'tickets.approve_ticket',
            'tasks.execute_task'
        ],
        'description': '主机管理和工单审批权限'
    },
    'operator': {
        'name': '运维操作员',
        'permissions': [
            'hosts.view_host',
            'tickets.create_ticket',
            'tasks.view_task'
        ],
        'description': '基础运维操作权限'
    },
    'auditor': {
        'name': '审计员',
        'permissions': [
            'hosts.view_host',
            'tickets.view_ticket',
            'audit.view_log'
        ],
        'description': '只读审计权限'
    }
}
```

#### 对象级权限控制
```python
# 主机访问权限检查
def check_host_permission(user, host, required_level='read'):
    """
    检查用户对主机的访问权限
    required_level: read, operate, admin
    """
    if user.is_superuser:
        return True
    
    permission = HostPermission.objects.filter(
        user=user,
        host=host,
        is_active=True
    ).first()
    
    if not permission:
        return False
    
    # 权限等级检查
    level_hierarchy = {'read': 1, 'operate': 2, 'admin': 3}
    return level_hierarchy.get(permission.level, 0) >= level_hierarchy.get(required_level, 0)
```

### 3.2 数据隔离策略

#### 多租户数据隔离
```python
# 基于主机的访问控制混入类
class HostScopedMixin:
    def get_queryset(self):
        queryset = super().get_queryset()
        if not self.request.user.is_superuser:
            # 只返回用户有权限访问的主机数据
            accessible_hosts = HostPermission.objects.filter(
                user=self.request.user,
                is_active=True
            ).values_list('host_id', flat=True)
            queryset = queryset.filter(host_id__in=accessible_hosts)
        return queryset

# 在 Admin 中使用
@admin.register(AccountOpeningRequest)
class AccountOpeningRequestAdmin(HostScopedMixin, admin.ModelAdmin):
    list_display = ['request_number', 'host', 'applicant', 'status']
    list_filter = ['status', 'host']
```

## 4. 数据安全

### 4.1 敏感数据加密

#### WinRM 凭证加密
```python
from cryptography.fernet import Fernet
import base64
import os

class CredentialEncryption:
    def __init__(self):
        # 从环境变量获取密钥
        key = os.environ.get('CREDENTIAL_ENCRYPTION_KEY')
        if not key:
            raise ValueError("加密密钥未配置")
        self.cipher_suite = Fernet(base64.urlsafe_b64encode(key.encode()[:32]))
    
    def encrypt(self, plaintext):
        """加密敏感数据"""
        if not plaintext:
            return None
        return self.cipher_suite.encrypt(plaintext.encode()).decode()
    
    def decrypt(self, ciphertext):
        """解密敏感数据"""
        if not ciphertext:
            return None
        return self.cipher_suite.decrypt(ciphertext.encode()).decode()

# 使用示例
encryption = CredentialEncryption()
encrypted_password = encryption.encrypt("MySecretPassword123!")
decrypted_password = encryption.decrypt(encrypted_password)
```

#### 数据库存储加密
```python
# models.py
from django.db import models
from .encryption import CredentialEncryption

class Host(models.Model):
    hostname = models.CharField(max_length=255)
    ip_address = models.GenericIPAddressField()
    winrm_username = models.CharField(max_length=100)
    _winrm_password = models.TextField(db_column='winrm_password')  # 加密存储
    
    encryption = CredentialEncryption()
    
    @property
    def winrm_password(self):
        return self.encryption.decrypt(self._winrm_password)
    
    @winrm_password.setter
    def winrm_password(self, value):
        self._winrm_password = self.encryption.encrypt(value)
```

### 4.2 数据备份安全

#### 加密备份脚本
```bash
#!/bin/bash
# encrypted_backup.sh

BACKUP_DIR="/secure/backups"
DATE=$(date +%Y%m%d_%H%M%S)
ENCRYPTION_KEY="/secure/keys/backup.key"

# 数据库备份并加密
pg_dump -h localhost -U zasca_user zasca_prod | \
    gpg --cipher-algo AES256 --compress-algo 1 --symmetric --batch --passphrase-file "$ENCRYPTION_KEY" \
    > "${BACKUP_DIR}/zasca_${DATE}.sql.gpg"

# 验证备份完整性
gpg --decrypt --batch --passphrase-file "$ENCRYPTION_KEY" \
    "${BACKUP_DIR}/zasca_${DATE}.sql.gpg" > /dev/null

# 清理旧备份
find "$BACKUP_DIR" -name "*.sql.gpg" -mtime +30 -delete
```

## 5. 网络安全

### 5.1 TLS/SSL 配置

#### Nginx SSL 配置
```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL 证书
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;
    ssl_trusted_certificate /path/to/chain.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    # 其他安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Referrer-Policy "strict-origin-when-cross-origin";
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;
}
```

### 5.2 防火墙配置

#### UFW 规则
```bash
# 基础安全规则
ufw default deny incoming
ufw default allow outgoing

# 必需服务端口
ufw allow ssh                        # SSH (建议更改默认端口)
ufw allow 443/tcp                   # HTTPS
ufw allow from 192.168.1.0/24 to any port 5432  # PostgreSQL (仅内网)
ufw allow from 127.0.0.1 to any port 6379        # Redis (仅本地)

# 应用特定规则
ufw allow from monitoring-server-ip to any port 9100  # 监控端口

# 启用防火墙
ufw enable
```

#### IPTables 高级配置
```bash
#!/bin/bash
# advanced_firewall.sh

# 清空现有规则
iptables -F
iptables -X

# 默认策略
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# 允许回环接口
iptables -A INPUT -i lo -j ACCEPT

# 允许已建立连接
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# 允许特定端口
iptables -A INPUT -p tcp --dport 22 -j ACCEPT      # SSH
iptables -A INPUT -p tcp --dport 443 -j ACCEPT     # HTTPS
iptables -A INPUT -p tcp --dport 5432 -s 192.168.1.0/24 -j ACCEPT  # PostgreSQL

# 防止 SYN Flood 攻击
iptables -A INPUT -p tcp --syn -m limit --limit 5/s --limit-burst 10 -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP

# 防止端口扫描
iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

# 保存规则
iptables-save > /etc/iptables/rules.v4
```

## 6. 输入验证与防护

### 6.1 参数验证

#### 表单验证
```python
# forms.py
from django import forms
from django.core.validators import RegexValidator
import re

class HostForm(forms.ModelForm):
    hostname = forms.CharField(
        max_length=255,
        validators=[
            RegexValidator(
                regex=r'^[a-zA-Z0-9\-\.]+$',
                message='主机名只能包含字母、数字、连字符和点号'
            )
        ]
    )
    
    ip_address = forms.GenericIPAddressField(
        protocol='IPv4',
        validators=[
            RegexValidator(
                regex=r'^(?!127\.)(?!10\.)(?!172\.(1[6-9]|2[0-9]|3[01])\.)(?!192\.168\.)',
                message='不能使用私有IP地址范围',
                inverse_match=True
            )
        ]
    )
    
    class Meta:
        model = Host
        fields = ['hostname', 'ip_address', 'description']
```

#### API 参数验证
```python
# serializers.py
from rest_framework import serializers
import ipaddress

class HostSerializer(serializers.ModelSerializer):
    def validate_ip_address(self, value):
        try:
            ip = ipaddress.ip_address(value)
            # 拒绝私有IP
            if ip.is_private:
                raise serializers.ValidationError("不允许使用私有IP地址")
            # 拒绝特殊IP
            if ip.is_loopback or ip.is_multicast or ip.is_reserved:
                raise serializers.ValidationError("不允许使用特殊IP地址")
        except ValueError:
            raise serializers.ValidationError("无效的IP地址格式")
        return value
    
    def validate_hostname(self, value):
        if len(value) > 255:
            raise serializers.ValidationError("主机名长度不能超过255个字符")
        if not re.match(r'^[a-zA-Z0-9\-\.]+$', value):
            raise serializers.ValidationError("主机名包含非法字符")
        return value
```

### 6.2 XSS 和 CSRF 防护

#### Django 安全中间件配置
```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF 保护
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',  # Clickjacking 防护
]

# 安全配置
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_REFERRER_POLICY = 'strict-origin-when-cross-origin'

# CSRF 配置
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_TRUSTED_ORIGINS = ['https://your-domain.com']
```

## 7. 安全审计

### 7.1 操作日志记录

#### 审计装饰器
```python
# decorators.py
from functools import wraps
from django.utils import timezone
import json

def audit_log(action, resource_type=None):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 执行原函数
            result = func(*args, **kwargs)
            
            # 记录审计日志
            request = args[0] if args else kwargs.get('request')
            if hasattr(request, 'user') and request.user.is_authenticated:
                AuditLog.objects.create(
                    timestamp=timezone.now(),
                    user=request.user,
                    action=action,
                    resource_type=resource_type or func.__name__,
                    details=json.dumps({
                        'args': str(args[1:]) if len(args) > 1 else '',
                        'kwargs': str(kwargs),
                        'result': str(result)[:500]  # 限制长度
                    }),
                    ip_address=get_client_ip(request),
                    user_agent=request.META.get('HTTP_USER_AGENT', '')
                )
            
            return result
        return wrapper
    return decorator

# 使用示例
@audit_log('create_host', 'Host')
def create_host_view(request):
    # 视图逻辑
    pass
```

#### 审计模型
```python
# models.py
class AuditLog(models.Model):
    timestamp = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    action = models.CharField(max_length=100)
    resource_type = models.CharField(max_length=50)
    resource_id = models.IntegerField(null=True, blank=True)
    details = models.JSONField(default=dict)
    ip_address = models.GenericIPAddressField(null=True)
    user_agent = models.TextField(blank=True)
    severity = models.CharField(
        max_length=20,
        choices=[
            ('info', '信息'),
            ('warning', '警告'),
            ('error', '错误'),
            ('critical', '严重')
        ],
        default='info'
    )
    
    class Meta:
        indexes = [
            models.Index(fields=['timestamp']),
            models.Index(fields=['user']),
            models.Index(fields=['action']),
            models.Index(fields=['severity']),
        ]
```

### 7.2 异常行为检测

#### 安全监控脚本
```python
# security_monitor.py
import logging
from datetime import timedelta
from django.utils import timezone
from .models import AuditLog

logger = logging.getLogger('security')

class SecurityMonitor:
    @staticmethod
    def detect_suspicious_activity():
        """检测可疑活动"""
        now = timezone.now()
        one_hour_ago = now - timedelta(hours=1)
        
        # 检测频繁失败的登录尝试
        failed_logins = AuditLog.objects.filter(
            action='login_failed',
            timestamp__gte=one_hour_ago
        ).values('user', 'ip_address').annotate(count=models.Count('id'))
        
        for record in failed_logins:
            if record['count'] > 5:
                logger.warning(f"检测到可疑登录行为: 用户={record['user']}, IP={record['ip_address']}, 次数={record['count']}")
                # 可以触发告警或临时封禁IP
        
        # 检测异常时间段的敏感操作
        if now.hour < 6 or now.hour > 22:  # 非工作时间
            sensitive_actions = ['delete_host', 'modify_permissions', 'execute_task']
            suspicious_ops = AuditLog.objects.filter(
                action__in=sensitive_actions,
                timestamp__gte=one_hour_ago
            )
            
            if suspicious_ops.exists():
                logger.critical(f"非工作时间检测到敏感操作: {suspicious_ops.count()} 次")
        
        # 检测批量删除操作
        bulk_deletes = AuditLog.objects.filter(
            action='bulk_delete',
            timestamp__gte=one_hour_ago
        )
        
        if bulk_deletes.exists():
            logger.error(f"检测到批量删除操作: {bulk_deletes.count()} 次")
```

## 8. 应急响应

### 8.1 安全事件处理流程

#### 事件分级
```python
SECURITY_EVENT_LEVELS = {
    'LOW': {
        'description': '低风险事件',
        'response_time': '24小时内',
        'examples': ['多次登录失败', '扫描探测']
    },
    'MEDIUM': {
        'description': '中等风险事件',
        'response_time': '4小时内',
        'examples': ['权限异常访问', '可疑文件上传']
    },
    'HIGH': {
        'description': '高风险事件',
        'response_time': '1小时内',
        'examples': ['数据泄露尝试', '系统入侵']
    },
    'CRITICAL': {
        'description': '严重安全事件',
        'response_time': '立即响应',
        'examples': ['数据泄露', '系统瘫痪']
    }
}
```

#### 应急响应步骤
```python
class IncidentResponse:
    def __init__(self, event):
        self.event = event
        self.level = self.classify_event(event)
    
    def classify_event(self, event):
        """事件分类"""
        # 根据事件特征确定严重程度
        pass
    
    def contain_threat(self):
        """威胁遏制"""
        if self.level == 'CRITICAL':
            # 立即隔离受影响系统
            self.isolate_system()
            self.disable_compromised_accounts()
    
    def eradicate_threat(self):
        """威胁清除"""
        # 清除恶意代码
        # 修复漏洞
        # 重置受影响凭证
        pass
    
    def recover_system(self):
        """系统恢复"""
        # 从干净备份恢复
        # 验证系统完整性
        # 逐步恢复服务
        pass
    
    def document_incident(self):
        """事件记录"""
        # 详细记录事件处理过程
        # 更新安全策略
        # 总结经验教训
        pass
```

## 9. 合规性要求

### 9.1 数据保护法规

#### GDPR 合规检查清单
```python
GDPR_COMPLIANCE_CHECKLIST = {
    '数据主体权利': [
        '知情权 - 提供清晰的隐私政策',
        '访问权 - 允许用户查看个人数据',
        '更正权 - 允许用户更正不准确数据',
        '删除权 - 提供数据删除功能',
        '限制处理权 - 允许限制数据处理',
        '数据可携带权 - 提供数据导出功能'
    ],
    '技术措施': [
        '数据加密 - 传输和存储加密',
        '访问控制 - 严格的权限管理',
        '数据最小化 - 只收集必要数据',
        '隐私设计 - 隐私保护内置设计',
        '数据保护影响评估 - 定期评估'
    ]
}
```

### 9.2 安全标准遵循

#### ISO 27001 控制措施
```python
ISO_27001_CONTROLS = {
    'A.5 信息安全方针': [
        '制定信息安全方针',
        '信息安全方针的沟通',
        '信息安全方针的维护'
    ],
    'A.6 组织信息安全': [
        '内部组织',
        '信息安全协调',
        '信息安全职责分配'
    ],
    'A.8 资产管理': [
        '资产清单',
        '资产负责人',
        '信息分类'
    ],
    'A.9 人力资源安全': [
        '入职安全',
        '在职安全',
        '离职安全'
    ],
    'A.10 物理和环境安全': [
        '安全区域',
        '设备安全',
        '介质处理'
    ],
    'A.11 通信和操作管理': [
        '操作规程和职责',
        '第三方服务交付管理',
        '系统规划和验收'
    ],
    'A.12 信息安全事故管理': [
        '信息安全事件和改进管理的责任和程序',
        '信息安全事件报告',
        '信息安全事件的评估和决策'
    ]
}
```

## 10. 安全测试

### 10.1 渗透测试计划

#### 测试范围
```python
PENTEST_SCOPE = {
    '应用层测试': [
        '身份认证测试',
        '授权测试',
        '输入验证测试',
        '会话管理测试',
        '错误处理测试'
    ],
    '数据层测试': [
        'SQL注入测试',
        '数据加密测试',
        '备份安全测试'
    ],
    '网络层测试': [
        '端口扫描',
        '服务识别',
        '漏洞扫描',
        '渗透测试'
    ]
}
```

#### 自动化安全扫描
```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install bandit safety
    
    - name: Run Bandit security scan
      run: bandit -r . -lll
    
    - name: Check for vulnerable packages
      run: safety check
    
    - name: Run Django security checks
      run: python manage.py check --deploy
```

---
*文档版本：V1.0*  
*最后更新：2026年2月3日*